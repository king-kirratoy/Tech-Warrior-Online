<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tech Warrior: Alpha 3.0</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<style>
/* --- 1. CORE ENGINE & THEMING --- */
body { 
    margin: 0; 
    background: #0c1014; 
    color: #c8d2d9; 
    font-family: 'Verdana', 'Segoe UI', sans-serif; 
    overflow: hidden; 
}

#ui-layer {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none;
    z-index: 1000;
}

/* --- 2. GARAGE MENU (HANGAR) --- */
.stat-readout { 
    width: 950px; 
    padding: 25px; 
    border-radius: 10px;
    position: relative;
    overflow: hidden;
    pointer-events: auto; 
    background: linear-gradient(rgba(12, 16, 20, 0.85), rgba(12, 16, 20, 0.85)), 
                url('assets/hangar-bg.jpg');
    background-size: cover;
    background-position: center;
    border: 1px solid rgba(0, 255, 0, 0.4);
    box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
}

.row { 
    margin-bottom: 22px; 
    display: flex; 
    flex-direction: column; 
    gap: 6px; 
}

.row-label {
    font-size: 11px;
    color: rgba(0, 255, 0, 0.7);
    letter-spacing: 1.5px;
    text-transform: uppercase;
    font-weight: bold;
}

.options-group { display: flex; gap: 5px; }

button { 
    background: rgba(255, 255, 255, 0.04); 
    color: #c8d2d9; 
    border: 1px solid rgba(255, 255, 255, 0.1); 
    border-left: 3px solid transparent; 
    cursor: pointer; 
    padding: 10px 12px; 
    font-size: 13px;
    text-align: left; 
    flex: 1; 
    transition: all 0.2s ease;
    font-family: 'Segoe UI', sans-serif;
}

button:hover { 
    background: rgba(0, 255, 0, 0.08); 
    border-color: rgba(0, 255, 0, 0.3); 
}

button.active { 
    background: rgba(0, 255, 0, 0.12); 
    color: #fff; 
    border-color: rgba(0, 255, 0, 0.5);
    border-left: 3px solid #0f0;
    box-shadow: inset 8px 0 15px rgba(0, 255, 0, 0.05);
}

#deploy-btn {
    width: 100%;
    font-size: 18px;
    margin-top: 15px;
    padding: 15px;
    text-align: center; 
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(0, 255, 0, 0.1);
    border: 1px solid rgba(0, 255, 0, 0.5);
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.color-preview {
    width: 12px;
    height: 12px;
    display: inline-block;
    margin-right: 10px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    vertical-align: middle;
}

/* --- 3. COMBAT HUD --- */
#hud-container { 
    position: fixed; 
    bottom: 30px; 
    left: 30px; 
    z-index: 9999; 
    display: none;
    pointer-events: none;
}

.console-frame { 
    display: flex; 
    align-items: flex-end; 
    gap: 20px; 
    padding: 15px; 
    background: rgba(12, 16, 20, 0.85); 
    border-left: 4px solid #0f0; 
    box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.5);
}

.stats-group { display: flex; flex-direction: column; gap: 6px; }

.hud-label { 
    font-weight: bold; 
    font-size: 11px; 
    color: #0f0; 
    opacity: 0.8; 
    text-transform: uppercase; 
}

/* Health and Shield numerical readouts */
#hp-text, #sh-text {
    font-size: 11px;
    font-family: 'monospace';
    letter-spacing: 1px;
}

#hp-bar { width: 250px; height: 18px; background: rgba(0, 40, 0, 0.3); border: 1px solid rgba(0, 255, 0, 0.3); }
#hp-fill { height: 100%; background: #0f0; transition: width 0.2s; box-shadow: 0 0 10px rgba(0, 255, 0, 0.5); }

#sh-bar { width: 250px; height: 6px; background: rgba(0, 20, 40, 0.3); border: 1px solid rgba(0, 255, 255, 0.3); margin-top: 2px; }
#sh-fill { height: 100%; background: #00ffff; box-shadow: 0 0 8px #00ffff; transition: width 0.3s; }

/* --- 4. WEAPON & MODULE SLOTS --- */
#weapon-slots { display: flex; gap: 10px; align-items: flex-end; }

.weapon-container { display: flex; flex-direction: column; align-items: center; gap: 4px; }

.key-hint {
    font-size: 9px;
    font-weight: bold;
    color: #c8d2d9;
    opacity: 0.8;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.weapon-box { 
    width: 60px; height: 60px; 
    border: 1px solid rgba(0, 255, 0, 0.4); 
    background: rgba(255, 255, 255, 0.03); 
    display: flex; flex-direction: column; justify-content: center; align-items: center; 
    color: #c8d2d9; position: relative; overflow: hidden;   
}

.weapon-box.active-firing { border-color: #fff; box-shadow: 0 0 15px #fff; color: #fff; background: rgba(255, 255, 255, 0.1); }

.cd-overlay {
    position: absolute; bottom: 0; left: 0;
    width: 100%; height: 0%;
    background: rgba(255, 0, 0, 0.3);
    border-top: 2px solid #ff0000;
    pointer-events: none;
}

.arm-label { opacity: 0.5; font-size: 9px; text-transform: uppercase; }
.weap-name { font-weight: bold; font-size: 11px; }

/* --- 5. UTILITY CLASSES --- */
#weight-bar-bg {
    width: 100%; height: 8px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 10px;
    overflow: hidden;
}

#weight-bar-fill {
    height: 100%; background: #0f0;
    transition: width 0.3s ease;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.4);
}

.pulse-warning { animation: pulse 0.5s infinite alternate; }
@keyframes pulse { from { opacity: 1; filter: brightness(1.5); } to { opacity: 0.4; } }

::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: #0c1014; }
::-webkit-scrollbar-thumb { background: #0f0; }
</style>
</head>
<body>

<div id="ui-layer">
    <div class="stat-readout" id="garage-menu" style="width: 750px;">
        
        <h2 style="text-align:center; margin-top:0; margin-bottom: 25px; letter-spacing: 2px; color: #0f0;">--- MECH HANGAR ---</h2>
        
        <div style="display: flex; gap: 30px; align-items: flex-start;">
            
            <div style="flex: 1.4;">
                <div class="row">
                    <span class="row-label">■ Chassis</span>
                    <div class="options-group">
                        <button id="c-light" onclick="setChassis('light')">LIGHT</button>
                        <button id="c-medium" onclick="setChassis('medium')">MEDIUM</button>
                        <button id="c-heavy" onclick="setChassis('heavy')">HEAVY</button>
                    </div>
                </div>
      
                <div class="row">
                    <span class="row-label">■ Primary Weapon</span>
                    <div class="options-group">
						<button id="l-smg" onclick="setWeapon('L','smg')">SMG</button>
                        <button id="l-mg" onclick="setWeapon('L','mg')">MG</button>
						<button id="l-br" onclick="setWeapon('L','br')">BR</button>
						<button id="l-sg" onclick="setWeapon('L','sg')">SG</button>
						<button id="l-hr" onclick="setWeapon('L','hr')">HR</button>
                    </div>
                </div>

                <div class="row">
                    <span class="row-label">■ Secondary Weapon</span>
                    <div class="options-group">
						<button id="r-none" onclick="setWeapon('R','none')">NONE</button>
						<button id="r-sr" onclick="setWeapon('R','sr')">SR</button>
						<button id="r-gl" onclick="setWeapon('R','gl')">GL</button>
						<button id="r-rl" onclick="setWeapon('R','rl')">RL</button>
						<button id="r-plsm" onclick="setWeapon('R','plsm')">PLSM</button>
                    </div>
                </div>

                <div class="row">
                    <span class="row-label">■ System Modification</span>
                    <div class="options-group">
						<button id="m-none" onclick="setMod('none')">NONE</button>
                        <button id="m-jump" onclick="setMod('jump')">JUMP</button>
						<button id="m-shield" onclick="setMod('shield')">SHIELD</button>
						<button id="m-rage" onclick="setMod('rage')">RAGE</button>
						<button id="m-emp" onclick="setMod('emp')">EMP</button>
                    </div>
                </div>

                <div class="row">
                    <span class="row-label">■ Armour Color</span>
                    <div class="options-group">
                        <button id="col-00ff00" class="active" onclick="setColor(0x00ff00)">
                            <span class="color-preview" style="background: #00ff00;"></span> GREEN
                        </button>
                        <button id="col-0088ff" onclick="setColor(0x0088ff)">
                            <span class="color-preview" style="background: #0088ff;"></span> BLUE
                        </button>
                        <button id="col-ff3300" onclick="setColor(0xff3300)">
                            <span class="color-preview" style="background: #ff3300;"></span> RED
                        </button>
                        <button id="col-ffff00" onclick="setColor(0xffff00)">
                            <span class="color-preview" style="background: #ffff00;"></span> YELLOW
                        </button>
                    </div>
                </div>
            </div> 

		<div style="flex: 1; display: flex; flex-direction: column; align-items: center;">
                <div id="preview-container" style="width: 280px; height: 180px; border: 1px solid #0f0; background: rgba(0,20,0,0.5); display: flex; justify-content: center; align-items: center;">
                    <img id="preview-img" src="assets/medium-mech.png" style="max-width: 100%; max-height: 100%; object-fit: contain; filter: drop-shadow(0 0 5px #0f0);">
                </div>

                <div id="hp-display" style="text-align:center; font-weight:bold; font-size: 14px; color: #0f0; margin-top: 10px;">
					HP: 450
				</div>

                <div id="weight-display" style="text-align:center; font-weight:bold; font-size: 14px; margin-bottom: 4px; margin-top: 65px;">
                    WEIGHT: 0 / 100
                </div>

                <div id="weight-bar-bg" style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border: 1px solid #444; margin-bottom: 10px; overflow: hidden;">
                    <div id="weight-bar-fill" style="width: 0%; height: 100%; background: #0f0; transition: width 0.3s ease;"></div>
                </div>

                <button id="deploy-btn" onclick="deployMech()">DEPLOY MECH</button>
            </div> 
	
	</div> </div> </div> 
	<div id="hud-container">
		<div class="console-frame">
			<div class="stats-group">
				<div style="display: flex; justify-content: space-between; align-items: center;">
					<div class="hud-label">HEALTH</div>
					<div id="hp-text" style="font-size: 11px; color: #0f0; font-family: monospace;">450/450</div>
				</div>
				<div id="hp-bar"><div id="hp-fill" style="width: 100%;"></div></div>
            
				<div style="display: flex; justify-content: space-between; align-items: center; margin-top: 4px;">
					<div class="hud-label" style="color: #00ffff;">SHIELD</div>
					<div id="sh-text" style="font-size: 11px; color: #00ffff; font-family: monospace;">100/100</div>
				</div>
				<div id="sh-bar"><div id="sh-fill" style="width: 100%;"></div></div>
			</div>
			<div id="weapon-slots">
				<div class="weapon-container">
					<div class="key-hint">M1</div>
					<div id="slot-L" class="weapon-box">
						<div id="cd-L" class="cd-overlay"></div> 
						<span class="arm-label">PRIMARY</span>
						<span id="txt-L" class="weap-name">SMG</span>
					</div>
				</div>

				<div class="weapon-container">
					<div class="key-hint">F</div>
					<div id="slot-R" class="weapon-box">
						<div id="cd-R" class="cd-overlay"></div> 
						<span class="arm-label">SECONDARY</span>
						<span id="txt-R" class="weap-name">GL</span>
					</div>
				</div>

				<div class="weapon-container">
					<div class="key-hint">SPACE</div>
					<div id="slot-M" class="weapon-box">
						<div id="cd-M" class="cd-overlay"></div>
						<span class="arm-label">SYSTEM</span>
						<span id="txt-M" class="weap-name">JUMP</span>
					</div>
				</div>
			</div>

<script>
const WEAPONS = {
    // PRIMARY WEAPONS 
    'smg':   { name: 'SMG',   reload: 50,   dmg: 3,   weight: 25, bulletSize: 4,  speed: 900 },
    'mg':    { name: 'MG',    reload: 300,  dmg: 30,   weight: 50, bulletSize: 6,  speed: 850 },
    'sg':    { name: 'SG',    reload: 700,  dmg: 12,   weight: 75, bulletSize: 5,  speed: 600, pellets: 5, range: 600 },
	'br':    { name: 'BR',    reload: 1000,  dmg: 20,  weight: 75, bulletSize: 5,  speed: 1100, burst: 3 },
    'hr':    { name: 'HR',    reload: 1750, dmg: 120,  weight: 100, bulletSize: 12, speed: 1100 },

    // SECONDARY WEAPONS 
    'sr':    { name: 'SR',    reload: 2500, dmg: 200, weight: 125, bulletSize: 6,  speed: 2000 },
    'gl':    { name: 'GL',    reload: 2000, dmg: 150, weight: 125, explosive: true },
    'rl':    { name: 'RL',    reload: 2500, dmg: 180,  weight: 150, explosive: true, bulletSize: 12, speed: 800},
    'plsm':  { name: 'PLSM',  reload: 3500, dmg: 300, weight: 150, size: 30 },

    // SYSTEM MODIFICATIONS
    'none':   { name: 'NONE',   reload: 0, dmg: 0, weight: 0 },
    'jump':   { name: 'JUMP',   reload: 0, dmg: 0, weight: 25 },
    'shield': { name: 'SHIELD', reload: 0, dmg: 0, weight: 50, activeTime: 2000, cooldown: 8000, isShield: true },
	'rage': { name: 'RAGE', weight: 75, duration: 3000, cooldown: 12000 },
	'emp':    { name: 'EMP',  weight: 75, radius: 250,  cooldown: 10000 }
};

const CHASSIS = {
    light:  { max: 75, spd: 400, scale: 0.7, hp: 350 }, 
    medium: { max: 150, spd: 280, scale: 1.0, hp: 450 },
    heavy:  { max: 250, spd: 180, scale: 1.4, hp: 650 }
};

// --- INITIAL LOADOUT CONFIGURATION --- //
let loadout = {
    chassis: 'light',  
    L: 'smg',
    R: 'none',     
    mod: 'none',
    color: 0x00ff00 
};

// --- GLOBAL VARIABLES --- //
let player, torso, keys, enemies, bullets, shieldGraphic;
let reloadBar, reloadBg, smokeParticles;

// --- MECH STATE TRACKING --- //
let isDeployed = false;
let activeArm = 'L';
let reloadL = 0;
let reloadR = 0;
let lastDamageTime = -99999;
let isJumping = false;
let isShieldActive = false; 
let isRageActive = false;
let lastModTime = 0;      

const config = {
    type: Phaser.AUTO,
    parent: 'game-container', 
    width: window.innerWidth, 
    height: window.innerHeight,
    physics: { default: 'arcade' },
    scene: { preload: preload, create: create, update: update }
};
const game = new Phaser.Game(config);

function preload() {
    let g = this.make.graphics({x: 0, y: 0, add: false});
    g.fillStyle(0xffffff, 1); 
	g.fillCircle(10, 10, 10);
    g.generateTexture('smoke', 20, 20);
}

function darkenColor(hex, amount = 0.4) {
    if (hex === undefined || hex === null) return 0x333333; // Emergency fallback
    let r = ((hex >> 16) & 0xFF) * amount;
    let g = ((hex >> 8) & 0xFF) * amount;
    let b = (hex & 0xFF) * amount;
    return (Math.floor(r) << 16) | (Math.floor(g) << 8) | Math.floor(b);
}

function create() {
    this.add.grid(window.innerWidth/2, window.innerHeight/2, 4000, 4000, 64, 64, 0, 0, 0x004400, 0.3);
    keys = this.input.keyboard.addKeys('W,A,S,D,SPACE,F');
    bullets = this.physics.add.group();
    enemies = this.physics.add.group();

    this.physics.add.overlap(bullets, enemies, (bullet, enemy) => {
		if (!bullet.isGLBall) {
		    createImpactSparks(this, enemy.x, enemy.y);
			let dmg = bullet.damageValue || 2; 
		    showDamageText(this, enemy.x, enemy.y, dmg);
			bullet.destroy(); 
			damageEnemy(enemy, dmg); 
		}
	});

    for(let i=0; i<6; i++) spawnEnemy(this);

    this.hangarOverlay = this.add.rectangle(window.innerWidth/2, window.innerHeight/2, window.innerWidth, window.innerHeight, 0x0c1014, 0.7).setScrollFactor(0).setDepth(1000);
    this.hangarGrid = this.add.grid(window.innerWidth/2, window.innerHeight/2, window.innerWidth, window.innerHeight, 16, 16, 0, 0, 0x00ff00, 0.05).setScrollFactor(0).setDepth(1001);
}

function createMuzzleFlash(scene, x, y, angle, distance = 40, color = 0xffffff) {
    if (!scene || !scene.add) return;

    // Position the flash at the barrel tip
    let fx = x + Math.cos(angle) * distance;
    let fy = y + Math.sin(angle) * distance;
    
    // Created with a smaller radius (6) and white color
    let flash = scene.add.circle(fx, fy, 6, color, 1).setDepth(15);
    
    // Add a tiny "shrink" animation to make it look less static
    scene.tweens.add({
        targets: flash,
        scale: 0.2,
        duration: 50,
        onComplete: () => flash.destroy()
    });
}

function createImpactSparks(scene, x, y) {
    for (let i = 0; i < 4; i++) {
        let spark = scene.add.rectangle(x, y, 6, 2, 0xffffff).setDepth(20);
        scene.physics.add.existing(spark);
        
        let angle = Math.random() * Math.PI * 2;
        let speed = 200 + Math.random() * 200;
        
        scene.physics.velocityFromRotation(angle, speed, spark.body.velocity);
        
        scene.tweens.add({
            targets: spark,
            alpha: 0,
            scaleX: 0,
            duration: 200,
            onComplete: () => spark.destroy()
        });
    }
}

function spawnEnemy(scene) {
    let x = Phaser.Math.Between(200, window.innerWidth - 200);
    let y = Phaser.Math.Between(200, window.innerHeight - 200);
    let e = scene.add.rectangle(x, y, 40, 40, 0xff0000).setStrokeStyle(2, 0xffffff);
    scene.physics.add.existing(e);
    
    e.health = 450; 
    e.maxHealth = 450; 
    
    e.bar = scene.add.rectangle(x, y-35, 40, 5, 0x00ff00);
    enemies.add(e);
}

function damageEnemy(e, amt) {
    e.health -= amt;
    if(e.bar) e.bar.width = Math.max(0, (e.health / e.maxHealth) * 40);
    
    if (e.health <= 0) { 
        if(e.bar) e.bar.destroy(); 
        e.destroy(); 
        setTimeout(() => spawnEnemy(game.scene.scenes[0]), 2000); 
    }
}

function deployMech() {
    document.getElementById('ui-layer').style.display = 'none';
    
    const hud = document.getElementById('hud-container');
    if (hud) {
        hud.style.display = 'flex'; 
    }
    
    let scene = game.scene.scenes[0];
    let s = CHASSIS[loadout.chassis];

    if (scene.hangarOverlay) scene.hangarOverlay.setVisible(false);
    if (scene.hangarGrid) scene.hangarGrid.setVisible(false);

    player = scene.add.rectangle(window.innerWidth/2, window.innerHeight/2, 70, 50, 0x222222).setStrokeStyle(2, 0xffffff).setDepth(5);
    scene.physics.add.existing(player);
    player.setScale(s.scale).body.setCollideWorldBounds(true);
    
    player.maxHp = s.hp; 
    player.hp = s.hp;
    player.maxShield = 100;
	player.shield = 100;

    torso = buildShapeMech(scene, loadout.chassis, loadout.color);
    torso.setDepth(10);
	refreshMechColor();
	scene.time.delayedCall(10, () => refreshMechColor());

    shieldGraphic = scene.add.circle(0, 0, 50, 0x00ffff, 0.15)
        .setStrokeStyle(2, 0x00ffff)
        .setVisible(false)
        .setDepth(12);
    
    smokeParticles = scene.add.particles(0, 0, 'smoke', { 
        scale: { start: 0.5, end: 0 }, 
        alpha: { start: 0.4, end: 0 }, 
        lifespan: 500, 
        speed: 30, 
        follow: player, 
        on: false 
    }).setDepth(4);

    player.isProcessingDamage = false; 
    lastDamageTime = -99999;
    lastModTime = -10000;
    isDeployed = true;
    updateHUD();
    updateBars();
}

function buildShapeMech(scene, type, color) {
    let container = scene.add.container(0, 0);
    let s = CHASSIS[type].scale;
    if (type === 'heavy') {
        let shoulders = scene.add.rectangle(0, 0, 40, 100, 0x333333).setStrokeStyle(2, 0xffffff);
        let core = scene.add.rectangle(0, 0, 60, 70, 0x333333).setStrokeStyle(2, 0xffffff);
		let head = scene.add.rectangle(0, 0, 40, 30, color).setStrokeStyle(2, 0xffffff).setName('mechHead');
        let cockpit = scene.add.rectangle(20, 0, 8, 30, 0x0F61A1).setStrokeStyle(1, 0xffffff);
        container.add([shoulders, core, head, cockpit]);
    } else if (type === 'light') {
        let shoulders = scene.add.rectangle(0, 0, 25, 60, 0x444444).setStrokeStyle(2, 0xffffff);
        let core = scene.add.rectangle(0, 0, 40, 40, 0x444444).setStrokeStyle(2, 0xffffff);
		let head = scene.add.rectangle(0, 0, 25, 20, color).setStrokeStyle(2, 0xffffff).setName('mechHead');
        let cockpit = scene.add.rectangle(10, 0, 10, 20, 0x0F61A1).setStrokeStyle(1, 0xffffff);
        container.add([shoulders, core, head, cockpit]);
    } else {
        let shoulders = scene.add.rectangle(0, 0, 35, 80, 0x444444).setStrokeStyle(2, 0xffffff);
        let core = scene.add.rectangle(0, 0, 50, 50, 0x444444).setStrokeStyle(2, 0xffffff);
		let head = scene.add.rectangle(0, 0, 35, 25, color).setStrokeStyle(2, 0xffffff).setName('mechHead');
        let cockpit = scene.add.rectangle(14, 0, 10, 25, 0x0F61A1).setStrokeStyle(1, 0xffffff);
        container.add([shoulders, core, head, cockpit]);
    }
    container.setScale(s);
    return container;
}

// WEAPON FIRING
function fire(scene, side) { 
    if (!isDeployed || isJumping) return;
    let now = scene.time.now;
    
    let wKey = (side === 'L') ? loadout.L : loadout.R;
    let weapon = WEAPONS[wKey];
    if (!weapon || wKey === 'none') return;

	let barrelDist = 40; // Default for Heavy
    if (loadout.chassis === 'light') barrelDist = 25;
    else if (loadout.chassis === 'medium') barrelDist = 32;

    let actualReload = isRageActive ? (weapon.reload * 0.5) : weapon.reload;
    let last = (side === 'L') ? reloadL : reloadR;

    // Check cooldown
    if (now < last) return;

    // Update HUD visual for the specific slot
    let slotId = 'slot-' + side;
    let slotEl = document.getElementById(slotId);
    if (slotEl) {
        slotEl.classList.add('active-firing');
        scene.time.delayedCall(100, () => slotEl.classList.remove('active-firing'));
    }

    // --- GRENADE LAUNCHER --- //
    if (wKey === 'gl') {
        let targetX = scene.input.activePointer.worldX;
        let targetY = scene.input.activePointer.worldY;
        let distance = Phaser.Math.Distance.Between(torso.x, torso.y, targetX, targetY);

        // 1. Create the Grenade
        let ball = scene.add.circle(torso.x, torso.y, 10, 0xffaa00).setStrokeStyle(2, 0xffffff).setDepth(14);
        scene.physics.add.existing(ball);
        scene.physics.velocityFromRotation(torso.rotation, distance * 2, ball.body.velocity);
        ball.body.setDrag(distance * 2); 

        // 2. Create the Yellow Timer Text
        let fuseTime = 2000; 
        let fuseStarted = false;
        let startTime = 0;
        
        let timerText = scene.add.text(ball.x, ball.y - 20, "2.0", {
            font: "bold 14px monospace",
            fill: "#ffff00"
        }).setOrigin(0.5).setDepth(15).setVisible(false);

        // 3. Update Loop
        let timerEvent = scene.time.addEvent({
            delay: 50,
            callback: () => {
                if (!ball.active) {
                    timerText.destroy();
                    timerEvent.destroy();
                    return;
                }
                timerText.setPosition(ball.x, ball.y - 20);
                let speed = ball.body.velocity.length();
                
                if (!fuseStarted && speed < 20) {
                    fuseStarted = true;
                    startTime = scene.time.now;
                    timerText.setVisible(true);
                    
                    scene.time.delayedCall(fuseTime, () => { 
                        if(ball.active) { 
                            createExplosion(scene, ball.x, ball.y, 100, weapon.dmg);
                            ball.destroy(); 
                            timerText.destroy();
                        }
                    });
                }

                if (fuseStarted) {
                    let elapsed = scene.time.now - startTime;
                    let remaining = Math.max(0, (fuseTime - elapsed) / 1000);
                    timerText.setText(remaining.toFixed(1));
                    if (remaining < 0.5) {
                        timerText.setFill(scene.time.now % 200 < 100 ? "#ffffff" : "#ff0000");
                    }
                }
            },
            loop: true
        });
    }
    
    // --- ROCKET LAUNCHER --- //
    else if (wKey === 'rl') {
        createMuzzleFlash(scene, torso.x, torso.y, torso.rotation, barrelDist);
        let rocket = scene.add.rectangle(torso.x, torso.y, 24, 10, 0xff4400).setDepth(14);
        scene.physics.add.existing(rocket);
        rocket.setRotation(torso.rotation);
        scene.physics.velocityFromRotation(torso.rotation, weapon.speed, rocket.body.velocity);

        let particles = scene.add.particles(0, 0, 'smoke', {
            speed: 20,
            scale: { start: 0.6, end: 0 },
            alpha: { start: 0.5, end: 0 },
            lifespan: 400,
            frequency: 20,
            blendMode: 'ADD',
            follow: rocket 
        }).setDepth(13);

        scene.physics.add.overlap(rocket, enemies, (r, e) => {
            createExplosion(scene, r.x, r.y, 80, weapon.dmg); 
			particles.stop();
			scene.time.delayedCall(400, () => particles.destroy());
            r.destroy();
        });

        scene.time.delayedCall(2000, () => {
            if (rocket.active) {
                particles.stop();
                scene.time.delayedCall(400, () => particles.destroy());
                rocket.destroy();
            }
        });
    }
    
    // --- SHOTGUN --- //
    else if (wKey === 'sg') {
        const pellets = weapon.pellets;
        const spread = 0.3; 
        for (let i = 0; i < pellets; i++) {
            let offsetAngle = (Math.random() - 0.5) * spread;
            let b = scene.add.circle(torso.x, torso.y, weapon.bulletSize, 0xffff00);
            createMuzzleFlash(scene, torso.x, torso.y, torso.rotation + offsetAngle, barrelDist);
            scene.physics.add.existing(b);
            b.damageValue = weapon.dmg;
            bullets.add(b);
            scene.physics.velocityFromRotation(torso.rotation + offsetAngle, weapon.speed, b.body.velocity);
            scene.time.delayedCall(800, () => { if(b.active) b.destroy(); }); 
        }
    }
    
    // --- PLASMA RIFLE --- //
    else if (wKey === 'plsm') {
        let p = scene.add.circle(torso.x, torso.y, 25, 0x00ffff).setAlpha(0.8);
        scene.physics.add.existing(p);
        p.damageValue = weapon.dmg;
        bullets.add(p);
        scene.physics.velocityFromRotation(torso.rotation, 300, p.body.velocity);
        scene.tweens.add({ targets: p, alpha: 0.3, duration: 100, yoyo: true, repeat: -1 });
        scene.time.delayedCall(3000, () => { if(p.active) p.destroy(); });
    }
    
    // --- STANDARD PROJECTILES (SMG, MG, BR, HR, SR) --- //
    else {
        const fireRound = (dmgValue, offsetAngle = 0) => {
            let b = scene.add.circle(torso.x, torso.y, weapon.bulletSize, 0xffff00);
            scene.physics.add.existing(b); 
            b.damageValue = dmgValue;
            bullets.add(b); 
            scene.physics.velocityFromRotation(torso.rotation + offsetAngle, weapon.speed, b.body.velocity);  
            
            // Standard yellow flash
            createMuzzleFlash(scene, torso.x, torso.y, torso.rotation + offsetAngle, barrelDist);
            
            scene.time.delayedCall(2000, () => { if(b.active) b.destroy(); });
        };

        if (wKey === 'br') {
            for (let i = 0; i < weapon.burst; i++) {
                scene.time.delayedCall(i * 60, () => fireRound(weapon.dmg, 0));
            }
        } else {
            fireRound(weapon.dmg, 0);
        }
        
        if (wKey === 'hr' || wKey === 'sr') {
            let recoil = (wKey === 'sr') ? 250 : 150;
            player.body.velocity.x -= Math.cos(torso.rotation) * recoil;
            player.body.velocity.y -= Math.sin(torso.rotation) * recoil;
            scene.cameras.main.shake(100, (wKey === 'sr' ? 0.01 : 0.005));
        }
    }

    if (side === 'L') reloadL = now + actualReload;
    else reloadR = now + actualReload;
}

function takePlayerDamage(amt) {
    // 1. Exit if player is invalid, shield mod is active, or we are already processing a hit
    if (!player || !player.active || isShieldActive || player.isProcessingDamage) return;
    
    // 2. Lock the function (This MUST be true to prevent the crash)
    player.isProcessingDamage = true;
    
    let currentTime = game.scene.scenes[0].time.now;
    lastDamageTime = currentTime; 
    player.lastHitTime = currentTime; 

    // 3. Damage Math
    if (player.shield > 0) {
        let shieldSoak = amt * 0.5;
        player.shield = Math.max(0, player.shield - shieldSoak);
        amt *= 0.5; 
    }
    player.hp = Math.max(0, player.hp - amt);
    
    // 4. Update the HUD
    updateBars();

    // 5. Unlock the function after a 50ms "grace period"
    game.scene.scenes[0].time.delayedCall(50, () => {
        if (player) player.isProcessingDamage = false;
    });

    // 6. Death Check
    if (player.hp <= 0) location.reload();
}

function refreshMechColor() {
    if (!torso || !torso.list || !isDeployed) return;

    let headColor = isRageActive ? 0xff0000 : loadout.color;
    // Core/Shoulders become 40% of the original brightness
    let bodyColor = isRageActive ? 0x660000 : darkenColor(loadout.color, 0.4);

    torso.list.forEach(shape => {
        // Only attempt to change color if the shape exists and has the property
        if (shape && shape.setFillStyle) {
            if (shape.name === 'mechHead') {
                shape.setFillStyle(headColor);
            } else if (shape.width >= 25) { 
                shape.setFillStyle(bodyColor);
            }
        }
    });
}

function updateBars() {
    if (!player || !isDeployed) return;

    // 1. Health Updates
    const hpFill = document.getElementById('hp-fill');
    const hpText = document.getElementById('hp-text');
    if (hpFill) {
        let hpPercent = (player.hp / player.maxHp) * 100;
        hpFill.style.width = Math.max(0, hpPercent) + "%";
        hpFill.style.background = hpPercent < 25 ? "#f00" : "#0f0";
    }
    if (hpText) {
        hpText.innerText = Math.ceil(Math.max(0, player.hp)) + "/" + player.maxHp;
    }

    // 2. Shield Updates (The likely crash site)
    const shFill = document.getElementById('sh-fill');
    const shText = document.getElementById('sh-text');
    
    // We use a fallback || 100 to prevent division by zero errors
    let mSh = player.maxShield || 100; 
    let shPercent = (player.shield / mSh) * 100;

    if (shFill) {
        shFill.style.width = Math.max(0, Math.min(100, shPercent)) + "%";
    }
    if (shText) {
        shText.innerText = Math.ceil(Math.max(0, player.shield)) + "/" + mSh;
    }
}

function update(time) {
    if (!isDeployed) return;

    // --- 1. INNATE SHIELD REGENERATION ---
    // Regenerates shield if no damage taken for 5 seconds
    let secondsSinceHit = (time - lastDamageTime) / 1000;

	// ONLY recharge if we've actually been hit before AND it's been 5 seconds
	if (lastDamageTime > 0 && secondsSinceHit >= 5) { 
		if (player.shield < player.maxShield) {
			player.shield += 1.0; // I lowered this slightly; 0.5 is very fast!
			if (player.shield > player.maxShield) player.shield = player.maxShield;
			updateBars();
		}
	}

    // --- 2. ENEMY AI MOVEMENT ---
    // Enemies seek the player unless they are currently stunned by EMP
    enemies.getChildren().forEach(enemy => {
        if (player && !enemy.isStunned) {
            let angleToPlayer = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
            enemy.body.setVelocity(
                Math.cos(angleToPlayer) * 100,
                Math.sin(angleToPlayer) * 100
            );
            if (enemy.bar) {
                enemy.bar.setPosition(enemy.x, enemy.y - 35);
            }
        } else if (enemy.isStunned) {
            // Freeze movement during EMP stun
            enemy.body.setVelocity(0, 0);
        }
    });

    // --- 3. DYNAMIC SPEED CALCULATION ---
    // Applies a 1.75x speed multiplier if Rage is active
    let s = CHASSIS[loadout.chassis].spd * (isRageActive ? 1.75 : 1);
	
    // --- 4. SPACEBAR MODULE ACTIVATION ---
    // Determine cooldown based on the specific module equipped
    let currentModCD = 2000; // Default for Jump
    if (loadout.mod === 'shield') currentModCD = 8000;
    else if (loadout.mod === 'emp') currentModCD = 10000;
    else if (loadout.mod === 'rage') currentModCD = 12000;

    // Trigger activation if Space is pressed and no other mod/jump is currently active
    if (keys.SPACE.isDown && !isJumping && !isShieldActive && !isRageActive && time > lastModTime + currentModCD) {
    
        if (loadout.mod === 'jump') {
            isJumping = true;
            this.physics.velocityFromRotation(player.rotation, 900, player.body.velocity);
            this.tweens.add({ 
                targets: [player, torso], 
                scale: '+=0.2', 
                duration: 200, 
                yoyo: true, 
                onComplete: () => {
                    isJumping = false;
                    lastModTime = game.scene.scenes[0].time.now;
                } 
            });
        } 
        else if (loadout.mod === 'shield') {
            isShieldActive = true;
            this.time.delayedCall(3000, () => { 
                isShieldActive = false; 
                lastModTime = game.scene.scenes[0].time.now;
            });
        }   
        else if (loadout.mod === 'rage') {
            isRageActive = true;
            refreshMechColor();

            this.time.delayedCall(3000, () => {
                isRageActive = false;
                refreshMechColor(); // Resets to base armor color
                lastModTime = game.scene.scenes[0].time.now;
            }); 
        }
        else if (loadout.mod === 'emp') {
            // Visual Ring Expansion
            let ring = this.add.circle(player.x, player.y, 10, 0x00ffff, 0.2).setStrokeStyle(2, 0x00ffff).setDepth(12);
            this.tweens.add({
                targets: ring,
                radius: 250,
                alpha: 0,
                duration: 400,
                onComplete: () => ring.destroy()
            });

            // Logic: Stun nearby enemies
            enemies.getChildren().forEach(enemy => {
                let dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
                if (dist < 250) {
                    enemy.isStunned = true;
                    enemy.setStrokeStyle(4, 0xffffff); // Highlight stun state
                    this.time.delayedCall(2500, () => {
                        enemy.isStunned = false;
                        enemy.setStrokeStyle(2, 0xffffff);
                    });
                }
            });
            lastModTime = time; // EMP is instant; cooldown starts now
        }
    }

    // PLAYER MOVEMENT CONTROLS
    if (!isJumping) {
        player.body.setVelocity(0);
        if (keys.W.isDown) this.physics.velocityFromRotation(player.rotation, s, player.body.velocity);
        if (keys.S.isDown) this.physics.velocityFromRotation(player.rotation, -s/2, player.body.velocity);
        if (keys.A.isDown) player.body.setAngularVelocity(-200);
        else if (keys.D.isDown) player.body.setAngularVelocity(200);
        else player.body.setAngularVelocity(0);
    }

    // Primary Fire (Hold Left Click)
	if (this.input.activePointer.isDown) {
		fire(this, 'L');
	}

	// Secondary Fire (Hold F)
	if (keys.F.isDown) {
		fire(this, 'R');
	}

    if (isRageActive && time % 150 < 20) { // Spawns slightly less often (every 150ms)
		// We use the real buildShapeMech for that "Great" look
		let ghost = buildShapeMech(this, loadout.chassis, 0xff0000);
		ghost.setPosition(torso.x, torso.y).setRotation(torso.rotation);
    
		// Force the "Red Fury" tint on all parts
		ghost.list.forEach(shape => {
			if (shape.setTint) shape.setTint(0xff0000);
		});

		ghost.setAlpha(0.4).setDepth(9);
    
		this.tweens.add({
			targets: ghost,
			alpha: 0,
			scale: 1.1, 
			duration: 400,
			onComplete: () => ghost.destroy() // Critical for preventing crashes
		});
	}

    // VISUAL POSITIONING 
    torso.setPosition(player.x, player.y);
    let angle = Phaser.Math.Angle.Between(player.x, player.y, this.input.activePointer.worldX, this.input.activePointer.worldY);
    torso.setRotation(angle);
    
    // Position and toggle the blue shield bubble
    shieldGraphic.setPosition(player.x, player.y).setVisible(isShieldActive);
	
    // --- 7. HUD COOLDOWN VISUALS ---
    if (isDeployed) {
        // Primary Weapon Cooldown
        let cdL = document.getElementById('cd-L');
        if (cdL && loadout.L !== 'none') {
            let totalTime = WEAPONS[loadout.L].reload;
            let remaining = Math.max(0, reloadL - time);
            let percent = (totalTime > 0) ? (remaining / totalTime) * 100 : 0;
            cdL.style.height = percent + "%";
        }

        // Secondary Weapon Cooldown
        let cdR = document.getElementById('cd-R');
        if (cdR && loadout.R !== 'none') {
            let totalTime = WEAPONS[loadout.R].reload;
            let remaining = Math.max(0, reloadR - time);
            let percent = (totalTime > 0) ? (remaining / totalTime) * 100 : 0;
            cdR.style.height = percent + "%";
        }
		
        // System Module Cooldown
        let cdM = document.getElementById('cd-M');
        let txtM = document.getElementById('txt-M');

        if (cdM && loadout.mod !== 'none') {
            if (txtM) txtM.innerText = loadout.mod.toUpperCase();

            let cooldownDuration = 2000;
            if (loadout.mod === 'shield') cooldownDuration = 8000;
            if (loadout.mod === 'emp') cooldownDuration = 10000;
            if (loadout.mod === 'rage') cooldownDuration = 12000;

            let elapsed = time - lastModTime;
            let percent = 0;

            // Stay at 100% height while active
            if (isShieldActive || isJumping || isRageActive) {
                percent = 100;
            } 
            // Drain while cooling down
            else if (lastModTime > 0 && elapsed < cooldownDuration) {
                percent = (1 - (elapsed / cooldownDuration)) * 100;
            }

            cdM.style.height = percent + "%";
        }
    }
}

function updateHUD() {
    const txtL = document.getElementById('txt-L');
    const txtR = document.getElementById('txt-R');
    const txtM = document.getElementById('txt-M');
    const slotL = document.getElementById('slot-L');
    const slotR = document.getElementById('slot-R');
    const slotM = document.getElementById('slot-M');

    if (txtL) txtL.innerText = loadout.L ? loadout.L.toUpperCase() : "---";
    if (txtR) txtR.innerText = loadout.R ? loadout.R.toUpperCase() : "---";
    if (txtM) txtM.innerText = loadout.mod ? loadout.mod.toUpperCase() : "NONE";

    // --- OPACITY LOGIC ---
    // Slots fade to 0.4 if NOTHING is equipped in them
    if (slotL) slotL.style.opacity = loadout.L === 'none' ? '0.4' : '1';
    if (slotR) slotR.style.opacity = loadout.R === 'none' ? '0.4' : '1';
    if (slotM) slotM.style.opacity = loadout.mod === 'none' ? '0.4' : '1';

    // --- BORDER COLOR LOGIC ---
    // Primary Slot: Blue if weapon equipped, Green if empty
    if (slotL) {
        slotL.style.borderColor = loadout.L !== 'none' ? '#00ffff' : 'rgba(0, 255, 0, 0.4)';
    }

    // Secondary Slot: Blue if weapon equipped, Green if empty
    if (slotR) {
        slotR.style.borderColor = loadout.R !== 'none' ? '#00ffff' : 'rgba(0, 255, 0, 0.4)';
    }
    
    // System slot remains Cyan if equipped
    if (slotM) {
        slotM.style.borderColor = loadout.mod === 'none' ? 'rgba(0, 255, 0, 0.4)' : '#00ffff';
    }
}

function setChassis(t) { 
    loadout.chassis = t; 
    refreshGarage(); 
}
function setWeapon(side, type) {
    if (side === 'L') loadout.L = type;
    else loadout.R = type;
    refreshGarage();
}

function setMod(type) {
    loadout.mod = type;
    refreshGarage();
}

function setColor(c) { loadout.color = c; refreshGarage(); }

function refreshGarage() {
    // 1. Reset all buttons
    document.querySelectorAll('button').forEach(b => b.classList.remove('active'));

    // 2. Highlight selected buttons
    let activeIDs = [
        'c-' + loadout.chassis, 
        'l-' + loadout.L, 
        'r-' + loadout.R, 
        'm-' + loadout.mod
    ];
	
	activeIDs.forEach(id => {
        let el = document.getElementById(id); 
        if (el) el.classList.add('active');
    });

    // 3. Highlight Color
    let hexColorString = loadout.color.toString(16).padStart(6, '0').toLowerCase();
    let colEl = document.getElementById("col-" + hexColorString);
    if (colEl) colEl.classList.add('active');

    // 4. Update Preview
    const previewImg = document.getElementById('preview-img');
    if (previewImg) {
        previewImg.src = `assets/${loadout.chassis}-mech.png`;
        previewImg.style.filter = `drop-shadow(0 0 15px #${hexColorString})`;
    }

    // 5. Weight Math (Safe because we have 'none' entries in WEAPONS now)
    let total = WEAPONS[loadout.L].weight + WEAPONS[loadout.R].weight + WEAPONS[loadout.mod].weight;
    let max = CHASSIS[loadout.chassis].max;
    let isOver = total > max;

    // 6. Update UI
    const weightDisplay = document.getElementById('weight-display');
    const barFill = document.getElementById('weight-bar-fill');
    const deployBtn = document.getElementById('deploy-btn');
	const hpDisplay = document.getElementById('hp-display');
	
    if (hpDisplay) {
        hpDisplay.innerText = "HP: " + CHASSIS[loadout.chassis].hp;
    }
    
    if (weightDisplay && barFill) {
        weightDisplay.innerText = `WEIGHT: ${total} / ${max}`;
        let percentage = Math.min(100, (total / max) * 100);
        barFill.style.width = percentage + "%";
        
        weightDisplay.style.color = isOver ? '#ff3300' : '#00ff00';
        barFill.style.background = isOver ? '#ff3300' : '#00ff00';
        
        if (deployBtn) {
            deployBtn.disabled = isOver;
            deployBtn.style.opacity = isOver ? "0.3" : "1.0";
            deployBtn.style.cursor = isOver ? "not-allowed" : "pointer";
            deployBtn.innerText = isOver ? "OVERWEIGHT" : "DEPLOY MECH";
        }
    }
}

function createExplosion(scene, x, y, radius, damage) {
    let blast = scene.add.circle(x, y, radius, 0xff6600, 0.6).setDepth(15);
    scene.physics.add.existing(blast);
    
    let hasDealtPlayerDamage = false; // Local scoped gate

    // Damage Enemies
    scene.physics.add.overlap(blast, enemies, (z, e) => {
        showDamageText(scene, e.x, e.y, damage);
        damageEnemy(e, damage);
    });

    // Damage Player
    if (player && player.active && !isShieldActive) {
        let dist = Phaser.Math.Distance.Between(x, y, player.x, player.y);
        if (dist < radius && !hasDealtPlayerDamage) {
            hasDealtPlayerDamage = true; 
            // Ensure we pass the damage clearly
            takePlayerDamage(Math.floor(damage * 0.75)); 
            scene.cameras.main.shake(200, 0.01);
        }
    }

    // Animation
    scene.tweens.add({ 
        targets: blast, 
        scale: 1.5, 
        alpha: 0, 
        duration: 300, 
        onComplete: () => blast.destroy() 
    });
}

function showDamageText(scene, x, y, amount) {
    let color = "#ffff00"; // Default: Electric Yellow
    let fontSize = "20px";

    if (amount >= 90 && amount < 150) {
        color = "#ffaa00"; // Brighter Neon Orange
        fontSize = "24px";
    } else if (amount >= 150) {
        color = "#ff0055"; // Brighter Laser Red/Magenta
        fontSize = "28px";
    }

    let dmgText = scene.add.text(x, y - 20, amount, {
        font: `bold ${fontSize} monospace`,
        fill: color,
        stroke: "#000000",
        strokeThickness: 4
    }).setOrigin(0.5).setDepth(20);

    // This adds the "Glow" effect to make the colors feel brighter
    dmgText.setShadow(0, 0, color, 8, true, true);

    scene.tweens.add({
        targets: dmgText,
        y: y - 100, // Floats a bit higher
        alpha: 0,
        scale: (amount >= 90 ? 1.3 : 1.0),
        duration: 2000,
		hold: 500,
        ease: 'Back.easeOut', // Adds a slight "pop" at the start
        onComplete: () => dmgText.destroy()
    });
}

window.onload = () => {
    refreshGarage();
    updateHUD(); 
};
</script>
</body>
</html>
