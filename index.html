<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tech Warrior: Patch 1.1</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style> body { margin: 0; background: #111; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; } </style>
</head>
<body>
<script>
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: { preload: preload, create: create, update: update }
};

const game = new Phaser.Game(config);
let player, keys, bullets, enemies;

function preload() {}

function create() {
    // 1. Better Input (Adding WASD + Arrows)
    keys = this.input.keyboard.addKeys('W,A,S,D,UP,LEFT,RIGHT,DOWN');

    // 2. Player Mech
    player = this.add.container(400, 300);
    let body = this.add.rectangle(0, 0, 40, 40, 0x333333).setStrokeStyle(2, 0x00ff00);
    let cannon = this.add.rectangle(20, 0, 30, 8, 0xaaaaaa);
    player.add([body, cannon]);
    
    this.physics.add.existing(player);
    player.body.setCollideWorldBounds(true);
    
    // FIX: Set Drag (Friction) so it stops when not pushing a key
    player.body.setDrag(300); 
    player.body.setAngularDrag(400);

    // 3. Bullets (Simplified)
    bullets = this.physics.add.group();
    
    // 4. Enemies
    enemies = this.physics.add.group();
    for(let i=0; i<5; i++) {
        let enemy = this.add.rectangle(Phaser.Math.Between(100, 700), Phaser.Math.Between(100, 500), 30, 30, 0xff3333);
        enemies.add(enemy);
        enemy.body.setBounce(1).setCollideWorldBounds(true).setVelocity(50, 50);
    }

    this.input.on('pointerdown', () => fireBullet(this));
    this.add.text(10, 10, 'WASD to Move | Click to Shoot', { color: '#00ff00', fontSize: '18px' });
}

function update() {
    // FIX: Movement Logic (Rotation)
    if (keys.A.isDown || keys.LEFT.isDown) {
        player.body.setAngularVelocity(-150);
    } else if (keys.D.isDown || keys.RIGHT.isDown) {
        player.body.setAngularVelocity(150);
    } else {
        player.body.setAngularVelocity(0);
    }

    // FIX: Forward/Backward Movement
    if (keys.W.isDown || keys.UP.isDown) {
        this.physics.velocityFromRotation(player.rotation, 200, player.body.velocity);
    } else if (keys.S.isDown || keys.DOWN.isDown) {
        this.physics.velocityFromRotation(player.rotation, -100, player.body.velocity);
    }

    // FIX: Bullet Cleanup (Prevents freezing/lag)
    bullets.children.each(bullet => {
        if (bullet.x < 0 || bullet.x > 800 || bullet.y < 0 || bullet.y > 600) {
            bullet.destroy();
        }
    });

    // Collision Logic
    this.physics.add.overlap(bullets, enemies, (bullet, enemy) => {
        bullet.destroy();
        enemy.destroy();
        // Respawn enemy somewhere else to keep the game going
        spawnEnemy(this);
    });
}

function fireBullet(scene) {
    let bullet = scene.add.rectangle(player.x, player.y, 10, 4, 0xffff00);
    scene.physics.add.existing(bullet);
    scene.physics.velocityFromRotation(player.rotation, 600, bullet.body.velocity);
    bullets.add(bullet);
}

function spawnEnemy(scene) {
    let enemy = scene.add.rectangle(Phaser.Math.Between(50, 750), Phaser.Math.Between(50, 550), 30, 30, 0xff3333);
    enemies.add(enemy);
    enemy.body.setBounce(1).setCollideWorldBounds(true).setVelocity(Phaser.Math.Between(-100, 100), Phaser.Math.Between(-100, 100));
}
</script>
</body>
</html>
